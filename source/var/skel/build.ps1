#Requires -Module Configuration, Pester

using namespace System.IO
using namespace System.Diagnostics

[CmdletBinding(DefaultParameterSetName = 'RunBuild')]
param(
    # The build type. Cannot use enum yet, it's not declared until this has executed.
    [Parameter(Position = 1)]
    [ValidateSet('Build', 'BuildTest', 'FunctionalTest', 'Release')]
    [String]$BuildType = 'Build',

    # The release type.
    [Parameter(Position = 2)]
    [ValidateSet('Build', 'Minor', 'Major')]
    [String]$ReleaseType = 'Build',

    # Return each the results of each build step as an object.
    [Parameter(ParameterSetName = 'RunBuild')]
    [Switch]$PassThru,

    # Return the BuildInfo object but do not run the build.
    [Parameter(ParameterSetName = 'GetInfo')]
    [Switch]$GetBuildInfo,

    # Suppress messages written by Write-Host.
    [Switch]$Quiet
)

class BuildOptions {
    [Boolean]$UseCommonBuildDirectory = $false

    [Double]$CodeCoverageThreshold = 0.9
}

class BuildInfo {
    # The name of the module being built.
    [String]$ModuleName = (Get-Item .).Parent.GetDirectories((Split-Path $pwd -Leaf)).Name

    # The build type.
    [ValidateSet('Build', 'BuildTest', 'FunctionalTest', 'Release')]
    [String]$BuildType = 'Build'

    # The release type.
    [ValidateSet('Build', 'Minor', 'Major')]
    [String]$ReleaseType = 'Build'

    # The root of this repository.
    [String]$ProjectRoot = ((git rev-parse --show-toplevel) -replace '/', ([Path]::DirectorySeparatorChar))

    # The root of the item which is being built.
    [String]$Source = (Get-Item $pwd).Parent.GetDirectories((Split-Path $pwd -Leaf)).Name

    # The package generated by the build process.
    [String]$Package

    # An output directory which stores files created by tools like Pester.
    [String]$Output

    [BuildOptions]$BuildOptions = [BuildOptions]::new()

    # Constructors

    BuildInfo($BuildType, $ReleaseType) {
        $this.BuildType = $BuildType
        $this.ReleaseType = $ReleaseType
    }

    # Private methods

    hidden [Version] GetCurrentVersion() {
        # Prefer to use version numbers from git.
        $version = [Version]'1.0.0.0'
        try {
            [String]$gitVersion = (git describe --tags) -replace '^v'
            if ([Version]::TryParse($gitVersion, [Ref]$version)) {
                return $this.IncrementVersion($version)
            }
        } catch {
            # Do nothing.
        }

        # Fall back to version numbers in the manifest.
        $sourceManifest = [Path]::Combine($this.Source, 'source', ('{0}.psd1' -f $this.ModuleName))
        if (Test-Path $sourceManifest) {
            $manifestVersion = Get-Metadata -Path $sourceManifest -PropertyName ModuleVersion
            if ([Version]::TryParse($manifestVersion, [Ref]$version)) {
                return $this.IncrementVersion($version)
            }            
        }

        return $version
    }

    hidden [Version] IncrementVersion($version) {
        $ctorArgs = switch ($this.buildType) {
            'Major' { ($version.Major + 1), 0, 0, 0 }
            'Minor' { $version.Major, ($version.Minor + 1), 0, 0 }
            'Build' { $version.Major, $version.Minor, ($version.Build + 1), 0 }
        }
        return New-Object Version($ctorArgs)
    }
}

# Supporting functions

function Invoke-Step {
    # .SYNOPSIS
    #   Invoke a build step.
    # .DESCRIPTION
    #   An output display wrapper to show progress through a build.
    # .INPUTS
    #   System.String
    # .OUTPUTS
    #   System.Object
    # .NOTES
    #   Author: Chris Dent
    #
    #   Change log:
    #     01/02/2017 - Chris Dent - Added help.
    
    param(
        [Parameter(ValueFromPipeline = $true)]
        $StepName
    )

    begin {
        $stopWatch = New-Object StopWatch
    }
    
    process {
        $progressParams = @{
            Activity = 'Building {0} ({1})' -f $this.ModuleName, $this.Version
            Status   = 'Executing {0}' -f $StepName
        }
        Write-Progress @progressParams

        $stepInfo = [PSCustomObject]@{
            Name      = $StepName
            Result    = 'Success'
            StartTime = [DateTime]::Now
            TimeTaken = $null
            Errors    = $null
        }
        $messageColour = 'Green'
        
        $stopWatch = New-Object System.Diagnostics.StopWatch
        $stopWatch.Start()

        try {
            if (Get-Command $StepName -ErrorAction SilentlyContinue) {
                & $StepName
            } else {
                $stepInfo.Errors = 'InvalidStep'
            }
        } catch {
            $stepInfo.Result = 'Failed'
            $stepInfo.Errors = $_
            $messageColour = 'Red'
        }

        $stopWatch.Stop()
        $stepInfo.TimeTaken = $stopWatch.Elapsed

        if (-not $Quiet) {
            Write-Host $StepName.PadRight(30) -ForegroundColor Cyan -NoNewline
            Write-Host -ForegroundColor $messageColour -Object $stepInfo.Result.PadRight(10) -NoNewline
            Write-Host $stepInfo.StartTime.ToString('t').PadRight(10) -ForegroundColor Gray -NoNewLine
            Write-Host $stepInfo.TimeTaken -ForegroundColor Gray
        }

        return $stepInfo
    }
}

function Write-Message {
    param(
        [String]$Object,

        [ConsoleColor]$ForegroundColor
    )

    $null = $psboundparameters.Remove('Quiet')
    if (-not $Script:Quiet) {
        Write-Host
        Write-Host @psboundparameters
        Write-Host
    }
}

# Steps



# Run the build

try {
    Push-Location $psscriptroot

    $buildInfo = New-Object BuildInfo($BuildType, $ReleaseType)
    if ($GetBuildInfo) {
        return $buildInfo
    } else {
        $Script:Quiet = $Quiet.ToBool()

        Write-Message ('Building {0} ({1})' -f $buildInfo.ModuleName, $buildInfo.Version)
        
        foreach ($step in $buildInfo.GetSteps($BuildType)) {
            $stepInfo = Invoke-Step $step.Name

            if ($PassThru) {
                $stepInfo
            }

            if ($stepInfo.Result -ne 'Success') {
                throw $stepinfo.Errors
            }
        }

        Write-Message "Build succeeded!" -ForegroundColor Green

        $lastexitcode = 0
    }
} catch {
    Write-Message 'Build Failed!' -ForegroundColor Red

    $lastexitcode = 1

    # Catches unexpected errors, rethrows errors raised while executing steps.
    throw
} finally {
    Pop-Location
}